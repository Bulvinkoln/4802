# Инструкция для работы с Git и удалёнными репозиториями.

Git – это программа для контроля версий, одна из реализаций распределённых систем контроля версий, имеющая, как и локальные, так и удалённые репозитории. Является самой популярной реализацией систем контроля версий в мире. Она позволяет отслеживать изменения в проекте и управлять ими, так как хранит разные версии проекта, что позволяет возвращаться к этим версиям. Git работает с текстовыми файлами, и для каждой следующей версии хранит не файлы целиком, а отличия от предыдущей версии для этих файлов, текущая же версия составляется им на основе всех предыдущих отличий.

## Основные команды Git.

### Версия Git:

* _**git --version**_ – Если Git установлен на компьютер, в выводе отобразится его текущая версия.

### Создание директории для репозитория:

Чтобы контролировать версии только определенных файлов – ограничить зону видимости для Git, для этого необходимо сделать отдельную папку, в которой будут находиться данные файлы, чтобы работать конкретно с ними, а не со всей файловой системой, а затем выбрать эту папку для создания в ней репозитория.

### Создание репозитория:

* _**git init**_ – Инициализирует локальный репозиторий в выбранной директории, и создаёт в ней скрытую папку **.git**, то есть организует в этой директории хранилище файлов, поддерживающее версионность, теперь Git видит все файлы внутри этого хранилища, и может отслеживать изменения в них.

### Просмотр состояния репозитория:

* _**git status**_ – Показывает текущее состояние репозитория: на какой ветке находится сейчас, отслеживаемые и неотслеживаемые файлы, есть ли изменения в файлах или нет, если есть изменения, то в каких файлах, добавлены ли эти файлы для фиксации в них изменений или нет, можно ли зафиксировать изменения или нет, зафиксированы изменения или нет, и т.п.

### Создание файлов:

Если в выбранной директории всё ещё отсутствуют необходимые файлы, тогда требуется добавить (создать или поместить) их туда.

### Редактирование файлов:

Внести изменения в файлы, и сохранить их (в Windows это **«Ctrl»+«S»**). Git управляет только сохраненными файлами, а не теми, что в процессе редактирования.

### Добавление файлов в отслеживаемые и фиксируемые:

* _**git add** "file_name.extension"_ – Указывает файл, изменения в котором будут зафиксированы при последующем создании новой версии, а при первом применении к файлу ещё и добавляет его в отслеживаемые. Также если файл имеет расширение, то имя файла необходимо обязательно написать с расширением.

**Автодополнение** – очень удобная функция терминала, позволяющая при вводе команды не набирать, к примеру, имя файла целиком, а набрать только несколько первых символов этого имени, нажать **«Tab»**, и терминал сам дозаполнит данные автоматически.

* _**git add .**_ – Добавляет все файлы из текущего репозитория в фиксируемые при последующем создании новой версии, при первом применении к файлам тоже добавляет их в отслеживаемые.

**Внимание!** Если внести дополнительные изменения в файл (даже если сохранить их в файле) после добавления этого файла для фиксации, но до самой фиксации, то эти изменения не будут добавлены в версию, созданную текущей фиксацией. Поэтому нужно будет либо повторно добавить файл для фиксации, чтобы дополнительные изменения попали в создаваемую версию, либо не вносить никаких изменений на данном этапе, а внести их уже в следующей версии. То есть, как только все нужные файлы добавлены для фиксации, следующим действием обязательно выполняем эту фиксацию.

Не принято фотографии и другие не текстовые файлы, занимающие большой объём памяти, добавлять в отслеживаемые, и чтобы Git больше не сообщал о них, что есть неотслеживаемые файлы, нужно чтобы он их игнорировал. Для этого создаём специальный стандартизированный файл **.gitignore** (без расширения), в нём указываем имена файлов, которые Git должен игнорировать, и уже его добавляем в отслеживаемые. Лучше создавать этот файл в ветке **master**.

### Фиксация изменений:

* _**git commit -m** "comment for this version"_ – Фиксирует текущее состояние указанных (добавленных) файлов, то есть создает новую версию этих файлов с внесенными изменениями. Ключ **-m** (message) позволяет написать комментарий, чтобы потом понимать какие изменения были внесены в данной версии, поэтому комментарий **ОБЯЗАТЕЛЕН**, к тому же он должен быть заключен в кавычки, также принято писать комментарий на английском языке, но и на русском он тоже сформируется. Все необходимые файлы должны быть предварительно **ДОБАВЛЕНЫ** для фиксации.
* _**git commit -am** "comment for this version"_ – Одновременно добавляет в фиксируемые только те файлы, в которых были сделаны изменения, и фиксирует их в новой версии. Не добавляет файл в отслеживаемые, так что для неотслеживаемых файлов всё равно потребуется предварительно применить команду _**git add**_.

**Внимание!** Git отслеживает файлы по имени, поэтому после изменения имени файла, необходимо будет добавить его в отслеживаемые с новым именем, а затем зафиксировать новую версию командой _**git commit**_.

### Журнал версий:

* _**git log**_ – Выводит список всех сделанных в репозитории фиксаций с их хеш-кодами для текущей ветки, начиная от последней к первой, если смотреть сверху вниз.
* _**git log --oneline**_ – Выводит все фиксации в виде краткого списка для текущей ветки, начиная от последней к первой, если смотреть сверху вниз.
* _**git log --graph**_ – Выводит список фиксаций в виде красивого графа (дерева).
Если список вывелся не полностью, то можно нажимать клавишу **«Enter»**, чтобы продолжать вывод более ранних фиксаций, а, чтобы перейти к вводу следующей команды нужно нажать кнопку **«q»** находясь в англоязычной раскладке клавиатуры.

### Перемещение между версиями:

* _**git checkout** hash_code_ – Переходит к другой фиксации, после _**git checkout**_ через пробел указывается хеш-код фиксации, к которой нужно перейти, можно указать хеш-код целиком, однако Git позволяет указать только первые 4 символа, этого достаточно чтобы понять к какой фиксации необходимо переключиться, например: _**git checkout 1a2b**_.
* _**git checkout master**_ – Переходит к самой последней созданной версии на ветке **master**, чтобы продолжить работу из самого актуального состояния.

### Вывод изменений:

* _**git diff**_ – Отображает разницу между текущим состоянием сохраненных файлов и последней зафиксированной версией.

### Откат до указанной версии:

* _**git reset --hard** hash_code_ – Возвращает состояние файла к версии, указанной в **hash_code**.

## Ветки в Git.

### Список веток:

* _**git branch**_ – Выводит список всех существующих веток в репозитории.

### Создание ветки:

* _**git branch** branch_name_ – Создает новую ветку с названием **branch_name**.

### Перемещение между ветками:

* _**git checkout** branch_name_ – Переходит на ветку **branch_name**, переключается к самой последней созданной фиксации на этой ветке.

### Создание + Переход:

* _**git checkout -b** branch_name_ – Создает новую ветку с названием **branch_name**, и одновременно переходит в неё (применяется чтобы не забыть перейти на вновь созданную ветку для работы в ней, а не в ветке **master**, например).

### Слияние веток:

* _**git merge** branch_name_ – Сливает ветку **branch_name** с текущей веткой. То есть необходимо сначала перейти с ветки **branch_name** на ту ветку в которую она будет присоединена – как пример, выполняется сначала переход на ветку **master**, а затем данная команда сливает ветку **branch_name** с веткой **master**.

Отменить слияние можно командой _**git reset --hard** hash_code_, перейдя на предыдущую фиксацию (последнюю созданную до слияния).

### Конфликт при слиянии:

* _**git merge --abort**_ – Отменяет слияние при наличии конфликта (однако сам конфликт не разрешится). Применяется только при возникновении конфликта, и до создания новой фиксации.

**Внимание!** После разрешения конфликта обязательно следует зафиксировать получившуюся версию.

### Удаление ветки:

* _**git branch -d** branch_name_ – Удаляет ветку **branch_name**. Лучше указать ключ **-d** (delete), хотя ключ **-D** тоже будет удалять, но c **-d** удаление выполняется только тогда, когда удаляемая ветка полностью влита в какую-либо другую ветку (когда эти ветки совмещены), и удаление не приведет к потере данных.

## Удалённые репозитории Git и GitHub.

### Создание удалённого репозитория:

Удалённые репозитории – это своего рода облачные хранилища для проектов Git с возможность совместной работы с ними. GitHub – это сервис Git от Microsoft для работы с удалёнными репозиториями, он не единственный, но самый популярный. Чтобы работать с репозиториями в GitHub необходимо создать на нём аккаунт (или иметь доступ в уже созданный). Создаются репозитории на внешнем сервисе не командой _**git init**_, а средствами самого удалённого сервиса (технически даже возможно работать с ними только на этом сервисе). Обращаться к созданному репозиторию можно по его URL адресу.

### Клонирование удалённого репозитория на локальный ПК:

* _**git clone** remote_URL_ – Клонирует удалённый репозиторий на локальный ПК, где создает его полную копию. В данном случае не требуется предварительно инициализировать Git, и даже создавать отдельную директорию на локальном ПК под копируемый репозиторий, так как по сути всё это уже создано в GitHub, и всё содержимое репозитория скачивается вместе с папкой, в которой оно находится, и название этой папки будет совпадать с названием удалённого репозитория, далее, чтобы работать с локальной копией нужно только перейти в данную папку. В качестве **remote_URL** указывается URL адрес внешнего репозитория, и наличия этого адреса достаточно, иметь доступ к аккаунту с копируемым репозиторием или создавать аккаунт на GitHub для клонирования не обязательно.

Примечания:
1. Клонируется только основная ветка (**main**).
2. Клонированный репозиторий уже связан с удалённым.

### Связывание локального репозитория с удалённым:

* _**git remote add** remote_name remote_URL_ – Связывает локальный репозиторий с удалённым, где **remote_name** это имя удаленного репозитория (по умолчанию **origin**), а **remote_URL** это его URL адрес. К примеру, позволяет связать существующий локальный репозиторий с только что созданным пустым внешним, когда вдруг потребовалось локальный проект выложить на GitHub. Далее уже можно будет только отправлять данные с локального репозитория, а Git будет доставлять их на связанный с ним удалённый репозиторий по URL адресу, указанному в этой команде, конечно при условии, что Visual Studio Code авторизован в аккаунте, в котором находится данный внешний репозиторий.

### Отправка изменений локальной ветки в удалённый репозиторий:

* _**git push**_ – Отправляет только из текущей ветки локального репозитория все изменения в соответствующую ветку связанного с ним удалённого репозитория.

Удаленный репозиторий автоматически не видит новые ветки, созданные локально, поэтому ветку нужно подключить, либо использовать команду:
* _**git push -u** remote_name branch_name_ – Подключает локально созданную ветку к связанному удалённому репозиторию, и отправляет на него все данные из этой ветки, где **remote_name** это имя удаленного репозитория (по умолчанию **origin**), а **branch_name** это имя ветки. Каждую ветку достаточно подключить только один раз, далее можно использовать просто _**git push**_ для отправки изменений.
* _**git push -u** origin main_ – Подключает локально созданную основную ветку main, к связанному удалённому репозиторию, и отправляет на него все данные из этой ветки. Применяется в ситуации, когда необходимо существующий локальный репозиторий выгрузить на только что созданный пустой внешний, например, когда вдруг потребовалось локальный проект выложить на GitHub.

**Внимание!** При первом использовании команды git push в конкретном аккаунте, Git запросит авторизацию, Visual Studio Code поможет её пройти.

### Загрузка изменений с удалённого репозитория в локальную ветку:

* _**git pull**_ – Загружает только в текущую ветку локального репозитория все изменения из соответствующей ветки удалённого репозитория. Применяется в ситуации, когда на удалённом репозитории находится более актуальное состояние текущей ветки (когда изменения на внешний репозиторий были внесены не из данного локального репозитория). Команда составная, то есть она сначала скачивает более актуальную версию из соответствующей ветки удалённого репозитория, а затем подобно команде _**git merge**_ сливает полученную версию с локальной версией текущей ветки.
